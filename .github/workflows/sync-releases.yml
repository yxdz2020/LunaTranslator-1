name: Sync Releases with Assets

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  UPSTREAM_REPO: 'HIllya51/LunaTranslator'  # 修改为您需要的仓库

jobs:
  sync-releases:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install @octokit/rest

      - name: Sync releases with assets
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node << 'EOF'
          const { UPSTREAM_REPO, GITHUB_TOKEN } = process.env;
          const [upstreamOwner, upstreamRepo] = UPSTREAM_REPO.split('/');
          const { Octokit } = require('@octokit/rest');
          const fs = require('fs');
          const path = require('path');

          const octokit = new Octokit({ auth: GITHUB_TOKEN });
          const [currentOwner, currentRepo] = process.env.GITHUB_REPOSITORY.split('/');
          
          async function downloadFile(url, filePath) {
            const response = await fetch(url);
            if (!response.ok) throw new Error('Download failed');
            const arrayBuffer = await response.arrayBuffer();
            fs.writeFileSync(filePath, Buffer.from(arrayBuffer));
          }
          
          async function syncReleases() {
            // 获取上游 releases
            const upstreamReleases = await octokit.repos.listReleases({
              owner: upstreamOwner,
              repo: upstreamRepo,
            });
            
            // 获取当前仓库 releases
            const currentReleases = await octokit.repos.listReleases({
              owner: currentOwner,
              repo: currentRepo,
            });
            
            const currentReleaseTags = new Set(currentReleases.data.map(r => r.tag_name));
            
            // 创建临时目录
            const tempDir = './temp_assets';
            if (!fs.existsSync(tempDir)) {
              fs.mkdirSync(tempDir, { recursive: true });
            }
            
            for (const release of upstreamReleases.data) {
              if (!release.draft && !release.prerelease && !currentReleaseTags.has(release.tag_name)) {
                console.log('Syncing release:', release.tag_name);
                
                // 创建 release
                const newRelease = await octokit.repos.createRelease({
                  owner: currentOwner,
                  repo: currentRepo,
                  tag_name: release.tag_name,
                  name: release.name || release.tag_name,
                  body: release.body || '',
                  draft: false,
                  prerelease: release.prerelease
                });
                
                // 同步附件
                if (release.assets && release.assets.length > 0) {
                  console.log('Syncing', release.assets.length, 'assets for:', release.tag_name);
                  
                  for (const asset of release.assets) {
                    try {
                      const tempFilePath = path.join(tempDir, asset.name);
                      console.log('Downloading:', asset.name);
                      
                      // 下载附件
                      await downloadFile(asset.browser_download_url, tempFilePath);
                      
                      // 上传附件
                      const fileContent = fs.readFileSync(tempFilePath);
                      await octokit.repos.uploadReleaseAsset({
                        owner: currentOwner,
                        repo: currentRepo,
                        release_id: newRelease.data.id,
                        name: asset.name,
                        data: fileContent,
                      });
                      
                      console.log('Uploaded:', asset.name);
                      fs.unlinkSync(tempFilePath);
                      
                    } catch (error) {
                      console.error('Failed to sync asset:', asset.name, error.message);
                    }
                  }
                }
                
                console.log('Successfully synced release:', release.tag_name);
              }
            }
            
            // 清理临时目录
            if (fs.existsSync(tempDir)) {
              fs.rmSync(tempDir, { recursive: true });
            }
          }
          
          syncReleases().catch(console.error);
          EOF

      - name: Cleanup
        run: |
          if [ -d "./temp_assets" ]; then
            rm -rf ./temp_assets
          fi
