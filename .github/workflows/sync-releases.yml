name: Sync Releases with Assets

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  UPSTREAM_REPO: 'HIllya51/LunaTranslator'  # 修改为您需要的仓库

jobs:
  sync-releases:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Sync releases with assets
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node -e "
          const { UPSTREAM_REPO, GITHUB_TOKEN } = process.env;
          const [upstreamOwner, upstreamRepo] = UPSTREAM_REPO.split('/');
          const { Octokit } = require('@octokit/rest');
          const fs = require('fs');
          const path = require('path');
          const https = require('https');
          const { promisify } = require('util');
          
          const octokit = new Octokit({ auth: GITHUB_TOKEN });
          const stream = require('stream');
          const pipeline = promisify(stream.pipeline);
          
          async function downloadFile(url, filePath) {
            const response = await fetch(url);
            if (!response.ok) throw new Error('Download failed');
            const arrayBuffer = await response.arrayBuffer();
            fs.writeFileSync(filePath, Buffer.from(arrayBuffer));
          }
          
          async function syncReleases() {
            // 获取上游 releases
            const upstreamReleases = await octokit.repos.listReleases({
              owner: upstreamOwner,
              repo: upstreamRepo,
            });
            
            // 获取当前仓库 releases
            const currentReleases = await octokit.repos.listReleases({
              owner: '${{ github.repository_owner }}',
              repo: '${{ github.event.repository.name }}',
            });
            
            const currentReleaseTags = new Set(currentReleases.data.map(r => r.tag_name));
            
            // 创建临时目录
            const tempDir = './temp_assets';
            if (!fs.existsSync(tempDir)) {
              fs.mkdirSync(tempDir);
            }
            
            for (const release of upstreamReleases.data) {
              if (!release.draft && !release.prerelease && !currentReleaseTags.has(release.tag_name)) {
                console.log('Syncing release:', release.tag_name);
                
                // 创建 release
                const newRelease = await octokit.repos.createRelease({
                  owner: '${{ github.repository_owner }}',
                  repo: '${{ github.event.repository.name }}',
                  tag_name: release.tag_name,
                  name: release.name || release.tag_name,
                  body: release.body || '',
                  draft: false,
                  prerelease: release.prerelease
                });
                
                // 同步附件
                if (release.assets && release.assets.length > 0) {
                  console.log('Syncing assets for:', release.tag_name);
                  
                  for (const asset of release.assets) {
                    try {
                      const tempFilePath = path.join(tempDir, asset.name);
                      
                      // 下载附件
                      console.log('Downloading:', asset.name);
                      await downloadFile(asset.browser_download_url, tempFilePath);
                      
                      // 上传附件
                      const fileContent = fs.readFileSync(tempFilePath);
                      await octokit.repos.uploadReleaseAsset({
                        owner: '${{ github.repository_owner }}',
                        repo: '${{ github.event.repository.name }}',
                        release_id: newRelease.data.id,
                        name: asset.name,
                        data: fileContent,
                        headers: {
                          'content-type': asset.content_type || 'application/octet-stream',
                          'content-length': asset.size
                        }
                      });
                      
                      console.log('Uploaded:', asset.name);
                      
                      // 清理临时文件
                      fs.unlinkSync(tempFilePath);
                    } catch (error) {
                      console.error('Failed to sync asset:', asset.name, error.message);
                    }
                  }
                }
                
                console.log('Successfully synced release:', release.tag_name);
              }
            }
            
            // 清理临时目录
            if (fs.existsSync(tempDir)) {
              fs.rmSync(tempDir, { recursive: true });
            }
          }
          
          syncReleases().catch(console.error);
        "

      - name: Cleanup
        run: |
          # 清理可能的临时文件
          if [ -d "./temp_assets" ]; then
            rm -rf ./temp_assets
          fi
