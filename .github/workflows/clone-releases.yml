name: Sync All Releases

on:
  workflow_dispatch:
    inputs:
      tag:
        description: '同步特定标签 (如 v1.4.3)。留空则同步所有版本。'
        required: false
        default: ''
        
  schedule:
    - cron: '0 2 * * *' # 每天凌晨2点自动运行

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # 授予创建 Release 的权限
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Sync Release using gh CLI
        env:
          # !!! 确保这里是你正确的上游仓库 !!!
          UPSTREAM_REPO: "HIllya51/LunaTranslator"
          SPECIFIC_TAG: ${{ inputs.tag }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # 阻止 gh 出现交互式提示
          GH_PROMPT_DISABLED: true
          
        run: |
          SYNC_TAGS="" # 最终同步的 tags 列表 (空格分隔)
          
          # 1. 获取上游真正的 "Latest" release 标签，用于后续判断
          echo "正在获取上游 [$UPSTREAM_REPO] 的 'Latest' 标签..."
          # || echo "" 确保在没有 latest release 时命令也不会失败
          LATEST_UPSTREAM_TAG=$(gh release view -R $UPSTREAM_REPO --json tagName -q .tagName || echo "")
          
          if [ -z "$LATEST_UPSTREAM_TAG" ]; then
            echo "警告：无法获取上游的 'Latest' 标签。所有同步的版本都将被标记为 '非-Latest'。"
          else
            echo "上游 'Latest' 标签是: $LATEST_UPSTREAM_TAG"
          fi

          # 2. 判断是同步指定版本还是所有缺失版本
          if [ -n "$SPECIFIC_TAG" ]; then
            # --- 手动指定了 Tag ---
            echo "已指定同步单个版本: $SPECIFIC_TAG"
            
            # 检查本地是否已存在
            if gh release view "$SPECIFIC_TAG" >/dev/null 2>&1; then
              echo "版本 [$SPECIFIC_TAG] 在你的仓库已存在，无需同步。"
              exit 0
            fi
            SYNC_TAGS=$SPECIFIC_TAG

          else
            # --- 自动或手动留空 ---
            echo "未指定版本，将检查所有缺失的 releases..."
            
            # 获取上游所有 releases 的 tag 列表 (包含 pre-releases)
            # tr 将换行符变为空格
            ALL_UPSTREAM_TAGS=$(gh release list -R $UPSTREAM_REPO --json tagName -q '.[].tagName' | tr '\n' ' ')
            if [ -z "$ALL_UPSTREAM_TAGS" ]; then
              echo "上游没有任何 releases，无需同步。"
              exit 0
            fi
            
            # 获取本地所有 releases 的 tag 列表
            LOCAL_TAGS=$(gh release list --json tagName -q '.[].tagName' | tr '\n' ' ')
            
            # 找出差异（只在上游存在的 tags）
            # 使用 comm 命令需要排序的、换行的输入
            # comm -23: 找出在文件1中独有，且不在文件2中的行
            MISSING_TAGS=$(comm -23 <(echo "$ALL_UPSTREAM_TAGS" | tr ' ' '\n' | sort) <(echo "$LOCAL_TAGS" | tr ' ' '\n' | sort) | tr '\n' ' ')
            
            if [ -z "$MISSING_TAGS" ]; then
              echo "本地仓库已是最新，无需同步。"
              exit 0
            fi
            
            SYNC_TAGS=$MISSING_TAGS
            echo "发现缺失的 releases: $SYNC_TAGS"
          fi

          # 3. 循环同步所有需要同步的 tags
          for TAG in $SYNC_TAGS; do
            echo "---"
            echo "正在处理 Tag: $TAG"
            
            # 4. 判断是否应设为 "Latest"
            LATEST_FLAG="--latest=false"
            if [ "$TAG" == "$LATEST_UPSTREAM_TAG" ]; then
              LATEST_FLAG="--latest=true"
              echo "这个版本将被标记为 'Latest'。"
            fi

            # 5. 下载附件
            # 清理并创建临时目录
            rm -rf temp_assets
            mkdir -p temp_assets
            echo "正在下载 [$TAG] 的附件..."
            # || true 确保在没有附件时脚本也不会失败
            gh release download "$TAG" -R $UPSTREAM_REPO -D temp_assets -p "*" || true

            # 6. 获取标题和正文
            REPO_TITLE=$(gh release view "$TAG" -R $UPSTREAM_REPO --json name -q .name)
            REPO_BODY=$(gh release view "$TAG" -R $UPSTREAM_REPO --json body -q .body)

            # 7. 创建 Release
            echo "正在创建 Release [$TAG] (设为 Latest: ${LATEST_FLAG})..."
            # temp_assets/* 会自动展开所有下载的附件
            # 如果没有附件，* 会匹配一个不存在的 "temp_assets/*" 字符串，gh 会忽略它
            gh release create "$TAG" temp_assets/* \
              --title "$REPO_TITLE" \
              --notes "Synced from $UPSTREAM_REPO. Original release notes:

            $REPO_BODY" \
              $LATEST_FLAG

            echo "同步 [$TAG] 完成！"
          done
          
          # 8. 最终清理
          rm -rf temp_assets
          echo "---"
          echo "所有同步任务已完成。"
